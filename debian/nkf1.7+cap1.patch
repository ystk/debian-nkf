nkf1.7+cap1.patch

このパッチは nkf 1.7 に CAP format で encode された
かな/漢字を decode する機能を追加します。
1999年2月に Akio Furukawa さんが fj.sources に投稿された
nkf1.62+cap1.patch を nkf 1.7 に適用するものです。
また同時に patch 1 for nkf 1.7 および
fj.sources.d に投稿された記事の内容も含んでいます。

**********************************************************

diff -urN nkf-1.7/cap1patch.doc nkf-1.7cap1/cap1patch.doc
--- nkf-1.7/cap1patch.doc	Thu Jan  1 09:00:00 1970
+++ nkf-1.7cap1/cap1patch.doc	Thu Mar  4 20:55:58 1999
@@ -0,0 +1,84 @@
+nkf1.7+cap1.patch
+
+概略
+
+このパッチは nkf 1.7 に CAP format で encode された
+かな/漢字を decode する機能を追加します。
+1999年2月に Akio Furukawa さんが NetNews に投稿された
+nkf1.62+cap1.patch を 1.7 に適用するものです。
+また同時に patch 1 for nkf 1.7 および、1998年11月に
+fj.sources.d に投稿された記事の内容も含んでいます。
+
+以下 nkf1.62+cap1.patch のドキュメントです。
+---------------------------------------------------------
+nkf1.62+cap1.patch
+
+1.概略
+
+このパッチは nkf 1.62 に CAP format で encode された
+かな/漢字を decode する機能を追加します。
+
+2.説明
+
+CAP (Columbia Appletalk Package）では AUFS (AppleTalk 
+UNIX File Server) という UNIX ベースの AppleShare 
+ファイルサーバーが提供されています。AUFS ではファイル
+名に含まれる かな/漢字 文字を、ある方法で変換して保存
+します。
+
+例えば、Macintosh から AUFS で公開されたボリュームに
+"書類" という名前のファイルを作製するとします。Mac
+側からは見えませんが、これは実際には ":8f:91:97:de"
+というファイル名で UNIX 上に作製されます。Mac 側から
+参照する際には AUFS が自動的に変換しています。
+
+しかし UNIX 側で同じファイルを参照する場合ファイル名は
+":8f:91:97:de" のままですから、ちょっと不便です。そこで、
+UNIX 側でこの変換されたファイル名を元に戻す機能を nkf
+1.62 に追加するのが nkf1.62+cap1.patch です。
+
+3.使い方
+
+かな/漢字のコード変換ツールとして広く使われている nkf 
+(Network Kanji Filter) のバージョン 1.62 のソース
+ファイルに nkf1.62+cap1.patch を適用して、コンパイル
+して下さい。出来上がった nkf のバイナリでは新たに -C
+オプションが追加され、このオプションが指定された時に
+は nkf の通常の処理に先立って CAP format に変換され
+ている かな/漢字 文字列を一旦内部的に SJIS コードに直
+します。
+
+従って、EUC の環境では
+
+% ls -l | nkf -C -e
+
+などとすれば AUFS で作製された日本語ファイル名の一覧を
+EUC コードの かな/漢字文字 として表示することが出来ます。
+nkf の使い方については、nkf のパッケージに付属のドキュ
+メントをお読み下さい。
+
+4.補足
+
+CAP と同じく UNIX 上で AppleShare ファイルサーバー機能
+を提供する netatalk でも、CAP と同じ かな/漢字 ファイル
+名の変換が行われています。また UNIX 上で MS Windows の
+ファイルサーバー機能を提供する samba においても、オプ
+ションで指定することにより CAP 方式の かな/漢字 ファイル
+名変換を行うようにすることが出来ます。(こうすると samba
+と CAP/netatalk で同じディレクトリを export する時に便利
+です。)
+
+従って、これらの環境においても nkf1.62+cap1.patch に
+よって機能追加された nkf を用いれば UNIX 側から かな/漢
+字混じりのファイル名を表示することが出来ます。
+
+nkf1.62+cap1.patch 
+(C) A. Furukawa 99/01/27
+akio@alumni.stanford.edu
+
+---------------------------------------------------------
+ここまで
+
+/////////////  坂井 浩人  (Hiroto Sakai) //////////
+
+        sakai@nuap.nagoya-u.ac.jp
diff -urN nkf-1.7/nkf.1 nkf-1.7cap1/nkf.1
--- nkf-1.7/nkf.1	Sun Nov  8 02:49:20 1998
+++ nkf-1.7cap1/nkf.1	Thu Mar  4 20:58:51 1999
@@ -137,6 +137,9 @@
 .TP
 .B \-d
 delete CR after NL.
+.TP
+.B \-C
+Decode CAP format kana/kanji words.
 .SH "FILES"
 nkf - binary
 .SH AUTHOR
diff -urN nkf-1.7/nkf.1j nkf-1.7cap1/nkf.1j
--- nkf-1.7/nkf.1j	Sun Nov  8 02:49:20 1998
+++ nkf-1.7cap1/nkf.1j	Thu Mar  4 21:02:18 1999
@@ -118,6 +118,9 @@
 .TP
 .B \-d
 NLあとのCRを削除する。
+.TP
+.B \-C
+CAP format で encode されたかな/漢字を decode する。
 
 .SH AUTHOR
 
diff -urN nkf-1.7/nkf.c nkf-1.7cap1/nkf.c
--- nkf-1.7/nkf.c	Sun Nov  8 02:49:21 1998
+++ nkf-1.7cap1/nkf.c	Thu Mar  4 20:55:58 1999
@@ -23,9 +23,11 @@
 static char *CopyRight =
       "Copyright (C) 1987, FUJITSU LTD. (I.Ichikawa),1998 S. Kono, COW";
 static char *Version =
-      "1.7";
+      "1.7+cap1";
 static char *Patchlevel =
-      "0/9711/Shinji Kono";
+      "1/9811/Shinji Kono";
+static char *CapPatchInfo =
+      "Patch for CAP format decode 1.0 (1999/01) (c) Akio Furukawa";
 
 /*
 **
@@ -66,6 +68,7 @@
 ** O   Output to 'nkf.out' file 
 ** d   Delete \r in line feed 
 ** c   Add \r in line feed 
+** C   Decode cap encoded kana/kanji
 **/
 /******************************/
 /* デフォルトの出力コード選択 */
@@ -81,6 +84,7 @@
 
 #ifndef PERL_XS
 #include <stdio.h>
+#include <ctype.h>
 #endif
 
 #if defined(MSDOS) || defined(__OS2__) 
@@ -148,10 +152,18 @@
 
 /* MIME preprocessor */
 
-#undef STRICT_MIME       /* do stupid strict mime integrity check */
+#define STRICT_MIME       /* do stupid strict mime integrity check */
 #define GETC(p) ((!mime_mode)?getc(p):mime_getc(p))
 #define UNGETC(c,p)     ((!mime_mode)?ungetc(c,p):mime_ungetc(c))
 
+/* CAP format decoding routines */
+
+#define hex2bin(x)                                              \
+    ( ((int) '0' <= ((int) (x)) && ((int) (x)) <= (int)'9')?    \
+        (((int) (x))-(int)'0'):                                 \
+      ((int) 'a'<= ((int) (x)) && ((int) (x))<= (int) 'f')?     \
+        (((int) (x)) - (int)'a'+10):                            \
+      (((int) (x)) - (int)'A'+10) )
 
 #ifdef EASYWIN /*Easy Win */
 extern POINT _BufferSize;
@@ -174,6 +186,7 @@
 static  int     mime_ungetc(unsigned int c);
 static  int     mime_integrity(FILE *f,unsigned char *p);
 static  int     base64decode(int c);
+static  int     cap_decode(unsigned char *cp);
 static  int     usage(void);
 static  void    arguments(char *c);
 static  void    reinit();
@@ -195,6 +208,10 @@
 static unsigned int            mime_last = 0;  /* decoded */
 static unsigned int            mime_input = 0; /* undecoded */
 
+/* CAP decoding buffers */
+#define       CAP_BUF_SIZE    (2)
+static unsigned char           cap_buf[CAP_BUF_SIZE];
+
 /* flags */
 static int             unbuf_f = FALSE;
 static int             estab_f = FALSE;
@@ -212,6 +229,7 @@
 #else
 static int             x0201_f = NO_X0201;     /* Assume NO JISX0201 */
 #endif
+static int             cap_f = FALSE;          /* decode cap format */
 
 /* X0208 -> ASCII converter */
 
@@ -579,6 +597,9 @@
 	case 'd':/* delete cr code */
 	    del_cr = TRUE;
 	    continue;
+        case 'C':/* decode cap format */
+            cap_f = TRUE;
+            continue;
 	default:
 	    /* bogus option but ignored */
 	    continue;
@@ -625,6 +646,35 @@
 #define LAST break         /* end of loop, go closing  */
 
     while ((c1 = GETC(f)) != EOF) {
+        if ( cap_f && c1==':' ) {
+                cap_buf[0] = GETC(f);
+                cap_buf[1] = GETC(f);
+                if ((c1 = cap_decode(cap_buf)) == '\0') {
+                    /* first word is not cap format */
+                    UNGETC(cap_buf[1],f);
+                    UNGETC(cap_buf[0],f);
+                    c1 = ':';
+                } else {
+                    /* first word is cap format - evaluate next word */
+                    if ((c2=GETC(f)) == ':') {
+                        cap_buf[0] = GETC(f);
+                        cap_buf[1] = GETC(f);
+                        if ((c2 = cap_decode(cap_buf)) == '\0') {
+                            /* next word starts with : but is not cap format */
+                            UNGETC(cap_buf[1],f);
+                            UNGETC(cap_buf[0],f);
+                            UNGETC(':',f);
+                        } else {
+                            /* next block is cap format */
+                            UNGETC(c2,f);
+                        }
+                    } else {
+                        /* next word is not cap format */
+                        UNGETC(c2,f);
+                    }
+                    c2 = 0;
+                }
+        } 
         if(c2) {
             /* second byte */
             if(c2 > DEL) {
@@ -1483,19 +1533,19 @@
 
 
 #ifdef STRICT_MIME
-/* This converts  ^\^\*/
+/* This converts  =?ISO-2022-JP?B?HOGE HOGE */
 
 unsigned char *mime_pattern[] = {
    (unsigned char *)"\075?ISO-8859-1?Q?",
    (unsigned char *)"\075?ISO-2022-JP?B?",
    (unsigned char *)"\075?ISO-2022-JP?Q?",
-   (unsigned char *)"\075?JAPANESE_EUC?B?",
+   (unsigned char *)"\075?EUC-JP?B?",
    (unsigned char *)"\075?SHIFT_JIS?B?",
    NULL
 };
 
 int      mime_encode[] = {
-    'Q', 'B', 'Q',
+    'Q', 'B', 'Q', 'B', 'B',
     0
 };
 #endif
@@ -1524,7 +1574,7 @@
     r[0]='='; r[1]='?';
 
     for(i=2;p[i]>' ';i++) {                   /* start at =? */
-        if( ((((r[i] = c1 = getc(f))==EOF) || nkf_toupper(c1) != p[i] ) {
+        if( ((r[i] = c1 = getc(f))==EOF) || nkf_toupper(c1) != p[i] ) {
             /* pattern fails, try next one */
             q = p;
             while (p = mime_pattern[++j]) {
@@ -1578,6 +1628,8 @@
         if( (r[i] = c1 = getc(f))==EOF) break;
 	if(c1=='=') break;
 	if(c1<' '&& c1!='\r' && c1!='\n') break;
+	if(!(('A'<=c1&&c1<='Z')||('a'<=c1&&c1<='z')||('0'<=c1&&c1<='9')
+	    ||c1=='_'||c1=='-'||c1=='?')) break;
 	if(c1=='?') {
 	    i++;
 	    if(!(i<MAXRECOVER) || (r[i] = c1 = getc(f))==EOF) break;
@@ -1821,6 +1873,22 @@
     del_cr = FALSE;
 }
 
+int
+cap_decode(cp)
+unsigned char *cp;
+{
+        switch (*cp) {
+        case '8': case '9': case 'a': case 'b': case 'c':
+        case 'd': case 'e': case 'f': case 'A': case 'B':
+        case 'C': case 'D': case 'E': case 'F':
+            if ( isxdigit(*(cp+1)) ) {
+                return ( (hex2bin(*cp)<<4) | (hex2bin(*(cp+1))) );
+            }
+        default :
+            return '\0';
+        }
+}
+
 #ifndef PERL_XS
 int 
 usage()   
@@ -1854,6 +1922,7 @@
 #endif
     fprintf(stderr,"O        Output to File (DEFAULT 'nkf.out')\n");
     fprintf(stderr,"d,c      Delete \\r in line feed, Add \\r in line feed\n");
+    fprintf(stderr,"C        Decode cap format kana/kanji\n");
     fprintf(stderr,"Network Kanji Filter Version %s (%s) "
 #if defined(MSDOS) && !defined(_Windows)
                   "for DOS"
@@ -1869,6 +1938,7 @@
 #endif
                   ,Version,Patchlevel);
     fprintf(stderr,"\n%s\n",CopyRight);
+    fprintf(stderr,"%s\n",CapPatchInfo);
     return 0;
 }
 #endif
@@ -1886,7 +1956,7 @@
  **  GHG00637@nifty-serve.or.jp (COW)
  **
  ** 最終更新日
- **  1998.11.7
+ **  1998.11.16
  **/
 
 /* end */
